/*

url: [{ hostContains: 'twitch.tv' }, { hostContains: 'reddit.com' }]
let urlArray = [{ url: '*://*.reddit.com/*' }, { url: '*://*.twitch.tv/*' }]
the two different styles of interfacing with urls

don't need any other sample code right now

need a deleteuserinput function to antimirror userinput
delete ruleset and from dict and from array in dict and decrement site count and remove listener

    console.log('deleting listener');
    chrome.webNavigation.onCompleted.removeListener(siteCache['reddit.com']);
    console.log('listener gone?');
*/

let urlStorage = ['reddit.com', 'twitch.tv'];
let timeS = { //timeS short for time storage
    closeTabs: { delayInMinutes: 1 },
    deactivate: { delayInMinutes: 2 } //these default to 1 & 2 but should be updated to user prefs
};
let siteCache = {
    dynamicIds: ['no 0th id', null, null, null, null, null, null, null, null, null, null],
    siteCount: 0,
    curRuleset: [] //this will be a list of all our rules to dynamically turn on and off
};

//so on button click [ to update settings] we need to do some tasks
//if there are any urls in the blocker section need to add them to the url storage
//then if the timer settings have changed you have to change them
//  // not sure how to validate if they're different and suggest a default setting but we'll see
//then gotta update our onvisitarray and our to query arrays

//separate on click button to delete a url
//and refresh the list of urls which should be one shorter


//this is a test oncompleted listener, when you go to test.com it triggers
//we're testing deactivating the listener with this before there's a button to push on their user settings
chrome.webNavigation.onCompleted.addListener(function () {

    let promise = chrome.declarativeNetRequest.getDynamicRules();
    console.log(promise); //this should return our ruleset?
}, {
    url: [{ hostContains: 'test.com' }]
})

chrome.runtime.onInstalled.addListener(
    function () {
        console.log('hello');
        userInputSite('reddit.com');
        userInputSite('twitch.tv');
        chrome.declarativeNetRequest.updateDynamicRules({ removeRuleIds: [1, 2] });
        //right now we don't do anything on installed
        //eventually we need to pull up a new tab with our options

        //have the user pick their website to block
        //have the option to pin the extension to the toolbar
    });

//this is our function for when a user adds a site to their banned list
async function userInputSite(urlString) {
    //check if userinput urlstring is already a rule in our dictionary
    if (urlString in siteCache) return;
    //now we have to check if we have too many sites in our cache- I don't want to overload the chrome ruleset maximum
    if (siteCache['siteCount'] >= 10) {
        let sitesMaxxed = new NotificationClass('Too Many Restricted Sites', 'The maximum amount of allowed site restrictions are 10. Please delete one or more of your current site restrictions to add new ones.');
        notifyUser(sitesMaxxed);
    }
    //first add site listener
    //logic to turn our listener registration function in to a named function, and then add the listener
    var newListener = function (details) {
        triggerOnCompleted(details);
    };
    chrome.webNavigation.onCompleted.addListener(newListener, { url: [{ hostContains: urlString }] });

    //gotta get the first null value in the array
    console.log(siteCache['dynamicIds']);
    let idNumber = null;
    for (let i = 1; i < siteCache['dynamicIds'].length; i++) { //start at 1 because 0 should never be null
        console.log(i, siteCache['dynamicIds'], siteCache['dynamicIds'][i]);
        if (siteCache['dynamicIds'][i] === null) {
            idNumber = i;
            siteCache['dynamicIds'][i] = urlString;
            console.log('set idNumber to ', i);
            break;
        };
    };
    //then we need to update our dictionary.
    //add url and paired function to restricted sites dictionary, increment our site count, add url to array
    siteCache[urlString] = newListener;
    siteCache['siteCount']++;

    //after updating all of this we should update our siteCache ruleset too
    siteCache['curRuleset'] = createDynamicRuleset(siteCache['dynamicIds']);
    //we can return our promise and then on success log it
    console.log(`successfully added site restriction for ${urlString}`);
    console.log(siteCache['curRuleset']);

};

//now we have two active alarms to listen for
chrome.alarms.onAlarm.addListener(function (alarm) {
    console.log(alarm.name);
    //chech which alarm we're looking at

    //the first alarm kicks us out of the tabs and initiates the blocker
    if (alarm.name === 'too much time on tab') {
        //first clear out our old notification
        notifyClear('You have accessed a restricted site');
        //now we make a new notification
        let timeOver = new NotificationClass('Activating Blocker',
            'Time allowed has expired. Access to restricted site is blocked and all tabs are closed. You will be allowed back on in [blockTime - allowedTime]');
        notifyUser(timeOver);
        console.log('activating blocker');
        activateBadge();
        //we can use the storaged ruleset in our object to enable and disable
        console.log(siteCache['curRuleset']);
        chrome.declarativeNetRequest.updateDynamicRules({ addRules: siteCache['curRuleset'] }); //update dynamic rules takes an object with addRules &/or removeRuleIds
        //on this alarm activating we want to query whether we have any open tabs of the problem website
        let queryArray = mapObjectsToQuery(siteCache['dynamicIds'])
        queryArray.forEach(url => //by acting on an array of url codes we can close the tabs of all of them
            chrome.tabs.query(url) //this returns a promise with all the problem urls. doesn't need Return prefix inside the forEach
                .then((tabs) => {
                    if (!tabs.length) return; //exit if we don't have any tabs found from the query

                    let map = tabs.map(t => t.id); // this creates a list of ids
                    chrome.tabs.remove(map); //close the tabs found
                    console.log('tabs from map successfully closed');
                }));
    };
    //the second alarm deactivates the blocker
    if (alarm.name === 'active ruleset timer') {
        //with the alarm triggered then we want to deactivate the ruleset again
        console.log('deactivating blocker');
        //instead of just a console log maybe we give a notification here
        deactivateBadge();
        deactivateRuleset();
        //now that the rules allow for use of the website again, we notify the user that they have access again
        notifyClear('Activating Blocker'); //clear out the old notification first
        let accessRestored = new NotificationClass('Access Restored', `Your time limit has expired, and you've regained access to your restricted site.`);
        notifyUser(accessRestored);
    };
});

//splitting the onCompleted listener logic into its own function to create new listeners every time a user
//adds a new site to their restricted websites
//you're allowed to visit website ony once, then this triggers and activates the ruleset
function triggerOnCompleted(details) {
    //need to make sure that this only triggers once per navigation
    console.log(details);
    if (details.frameId !== 0) return;

    //need to clear notifications left over from the last cycle of banning
    notifyClear('Access Restored');
    //to create a notification we create a new member of our class and pass that into the notify function
    let siteVisited = new NotificationClass('You have accessed a restricted site', 'You will be allowed [time] until you are kicked off of it.');
    //we notify the user and initiate a warning badge
    notifyUser(siteVisited);
    warningBadge();
    console.log('warning initiated, setting alarms');
    //here we've got to add two timers:
    //timer to boot you out of the reddit tab after x time
    chrome.alarms.create(name = 'too much time on tab', timeS.closeTabs);
    //then we need another alarm to turn the ruleset back off
    chrome.alarms.create(name = 'active ruleset timer', timeS.deactivate);
    console.log('both alarms successfully set');
};

//and here are two functions to turn on or off the badge
function activateBadge() {
    chrome.action.setBadgeBackgroundColor({ color: '#F00' }); //can add callback function if you want to cascade
    chrome.action.setBadgeText({ text: 'active' });
}
function deactivateBadge() {
    chrome.action.setBadgeText({ text: '' }); //this line successfully turns the badge off
}
//and a function to start the badge saying that your time on the site is counting down
function warningBadge() {
    chrome.action.setBadgeBackgroundColor({ color: '#FF6700' });
    chrome.action.setBadgeText({ text: 'allowed' });
}


//I want to create a class here to make creating the notifications object a little easier
let NotificationClass = class {
    constructor(title, message) {
        this.title = title;
        this.message = message;
        this.type = 'basic';
        this.iconUrl = './tyFav128.png';
        this.priority = 1;
        this.silent = true;
    }
};
//here are two functions to create a user notification, and one to delete notification objects
function notifyUser(notifObj) {
    chrome.notifications.create(notifObj.title, notifObj, function (notificationId) {
        console.log(notificationId, 'notification created');
    });
};
function notifyClear(notifId) {
    //if statement is unnecessary, no error if there isn't one.
    //Could add a check to make this console log not show up though
    chrome.notifications.clear(notifId, () => {
        console.log('old notification cleared');
    })
}

//map and forEach aren't working, so I've made two functions to make object arrays for url validation
function mapObjectsToQuery(arr) {
    let qArr = [];
    for (let i = 0; i < arr.length; i++) {
        qArr.push({ url: `*://*.${arr[i]}/*` });
    }
    return qArr;
};

//function to create a new ruleset for the set of urls
function createDynamicRuleset(urlArray) {
    //create a storage object for our new ruleset in the correct format for our dynamic ruleset
    let ruleset = [];
    //iterate over our list of website domains
    for (let i = 1; i < urlArray.length; i++) { //start at 1 because no 0 index
        if (urlArray[i] !== null) { //check if they're not empty slots
            let filter = `*://*.${urlArray[i]}/*` //convert to filter format
            //create an object that's the rule format with the input of the id number and the new filter formatted url
            let newRule = {
                'id': i + 69, //adding 69 to the id number to hopefully never overlap with other extension rules
                'priority': 1,
                'action': { 'type': 'block' },
                'condition': {
                    'urlFilter': filter,
                    'resourceTypes': ['main_frame']
                }
            };
            ruleset.push(newRule); //and push that rule into our list of rules
        }
    }
    return ruleset;
};

async function deactivateRuleset() {
    for (let i = 70; i <= 80; i++) {
        await chrome.declarativeNetRequest.updateDynamicRules({ removeRuleIds: [70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80] });
    }
};
